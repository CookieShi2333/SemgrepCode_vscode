package com.example.owasp.a11;

import java.io.*;
import java.nio.file.*;

/**
 * A11:2021 – Path Traversal (Directory Traversal)
 * 漏洞演示：路径遍历攻击允许攻击者访问不应该访问的文件
 */
public class PathTraversalVulnerability {
    
    private static final String BASE_DIR = "/app/upload/";
    
    /**
     * 漏洞代码：直接使用用户输入的文件路径，没有验证
     * 攻击示例：
     *  - userFilename = "../../../../etc/passwd" → 访问系统文件
     *  - userFilename = "../../config/database.properties" → 访问配置文件
     */
    public static String readFileVulnerable(String userFilename) throws IOException {
        // 漏洞：直接拼接用户输入到路径中
        String filePath = BASE_DIR + userFilename;
        
        // 攻击者可以通过相对路径遍历到任何地方
        // 实际路径：/app/upload/../../../../etc/passwd → /etc/passwd
        
        String content = new String(Files.readAllBytes(Paths.get(filePath)));
        return content;
    }
    
    /**
     * 漏洞代码：删除用户指定的文件，没有路径验证
     */
    public static void deleteFileVulnerable(String userFilename) throws IOException {
        String filePath = BASE_DIR + userFilename;
        
        // 攻击者可以删除关键系统文件
        Files.delete(Paths.get(filePath));
        System.out.println("File deleted: " + filePath);
    }
    
    /**
     * 漏洞代码：提供文件下载服务，但没有验证下载的文件
     */
    public static byte[] downloadFileVulnerable(String fileParam) throws IOException {
        // 攻击者可以下载任何敏感文件
        String filePath = "/app/data/" + fileParam;
        
        return Files.readAllBytes(Paths.get(filePath));
    }
    
    /**
     * 改进版本：验证路径不超出基础目录
     */
    public static String readFileSecure(String userFilename) throws IOException {
        // 步骤1：验证输入不为空且不包含危险字符
        if (userFilename == null || userFilename.isEmpty()) {
            throw new IllegalArgumentException("Filename cannot be empty");
        }
        
        // 步骤2：检查是否包含路径遍历字符（../、..\\、::等）
        if (userFilename.contains("..") || userFilename.contains("//") || 
            userFilename.startsWith("/") || userFilename.startsWith("\\")) {
            throw new IllegalArgumentException("Invalid path: path traversal detected");
        }
        
        // 步骤3：构建完整路径
        Path basePath = Paths.get(BASE_DIR).toRealPath();
        Path filePath = basePath.resolve(userFilename).toRealPath();
        
        // 步骤4：验证最终路径是否在基础目录内
        if (!filePath.startsWith(basePath)) {
            throw new SecurityException("Access denied: file is outside allowed directory");
        }
        
        // 步骤5：验证文件存在且是文件（不是目录）
        if (!Files.isRegularFile(filePath)) {
            throw new FileNotFoundException("File not found or is a directory");
        }
        
        // 步骤6：读取文件
        String content = new String(Files.readAllBytes(filePath));
        return content;
    }
    
    /**
     * 改进版本：使用文件白名单
     */
    public static String readFileWithWhitelist(String userFilename) throws IOException {
        // 定义允许访问的文件白名单
        String[] allowedFiles = {
            "document1.txt",
            "document2.txt",
            "report.pdf",
            "data.csv"
        };
        
        // 检查文件是否在白名单中
        boolean isAllowed = false;
        for (String allowed : allowedFiles) {
            if (allowed.equals(userFilename)) {
                isAllowed = true;
                break;
            }
        }
        
        if (!isAllowed) {
            throw new SecurityException("File not in allowed list");
        }
        
        // 使用白名单中的文件名构建路径
        Path filePath = Paths.get(BASE_DIR).resolve(userFilename).toRealPath();
        
        // 验证处理
        Path basePath = Paths.get(BASE_DIR).toRealPath();
        if (!filePath.startsWith(basePath)) {
            throw new SecurityException("Access denied");
        }
        
        return new String(Files.readAllBytes(filePath));
    }
    
    /**
     * 改进版本：删除文件时进行完整的验证
     */
    public static void deleteFileSecure(String userFilename) throws IOException {
        // 步骤1：验证输入
        if (userFilename == null || userFilename.isEmpty()) {
            throw new IllegalArgumentException("Filename cannot be empty");
        }
        
        // 步骤2：检查路径遍历尝试
        if (userFilename.contains("..") || userFilename.contains("//") || 
            userFilename.startsWith("/") || userFilename.startsWith("\\")) {
            throw new IllegalArgumentException("Invalid path: path traversal detected");
        }
        
        // 步骤3：规范化路径
        Path basePath = Paths.get(BASE_DIR).toRealPath();
        Path filePath = basePath.resolve(userFilename).toRealPath();
        
        // 步骤4：验证路径在基础目录内
        if (!filePath.startsWith(basePath)) {
            throw new SecurityException("Cannot delete files outside upload directory");
        }
        
        // 步骤5：可选的额外安全检查 - 检查文件是否在黑名单中
        String[] protectedFiles = {".htaccess", ".env", "config.php"};
        for (String protected_ : protectedFiles) {
            if (filePath.getFileName().toString().equals(protected_)) {
                throw new SecurityException("Cannot delete protected file");
            }
        }
        
        // 步骤6：删除文件
        Files.delete(filePath);
        System.out.println("File deleted securely: " + filePath);
    }
    
    /**
     * 改进版本：提供安全的文件下载
     */
    public static byte[] downloadFileSecure(String fileParam) throws IOException {
        // 步骤1：验证文件参数
        if (fileParam == null || fileParam.isEmpty()) {
            throw new IllegalArgumentException("File parameter cannot be empty");
        }
        
        // 步骤2：移除任何路径组件（只获取文件名）
        String filename = Paths.get(fileParam).getFileName().toString();
        
        // 步骤3：验证不包含危险字符
        if (!filename.equals(fileParam)) {
            throw new IllegalArgumentException("Invalid file path");
        }
        
        // 步骤4：构建安全的完整路径
        Path basePath = Paths.get("/app/data").toRealPath();
        Path filePath = basePath.resolve(filename).toRealPath();
        
        // 步骤5：验证路径在允许的目录内
        if (!filePath.startsWith(basePath)) {
            throw new SecurityException("Access denied: path outside allowed directory");
        }
        
        // 步骤6：验证文件存在且是文件
        if (!Files.isRegularFile(filePath)) {
            throw new FileNotFoundException("Invalid file");
        }
        
        return Files.readAllBytes(filePath);
    }
    
    /**
     * 工具方法：验证路径安全性
     */
    public static boolean isPathSafe(String userPath, String baseDirectory) {
        try {
            Path base = Paths.get(baseDirectory).toRealPath();
            Path target = base.resolve(userPath).toRealPath();
            
            // 路径必须在基础目录内
            return target.startsWith(base);
        } catch (IOException e) {
            return false;
        }
    }
    
    public static void main(String[] args) {
        System.out.println("=== Path Traversal Demo ===");
        
        System.out.println("\n=== Vulnerable Code ===");
        System.out.println("1. readFileVulnerable(\"../../../../etc/passwd\")");
        System.out.println("   Result: Reads /etc/passwd");
        System.out.println("2. deleteFileVulnerable(\"../../config.properties\")");
        System.out.println("   Result: Deletes critical configuration file");
        System.out.println("3. downloadFileVulnerable(\"../../../sensitive_data.txt\")");
        System.out.println("   Result: Downloads files outside intended directory");
        
        System.out.println("\n=== Secure Code ===");
        System.out.println("1. Path validation: Check for ../, ..\\ and absolute paths");
        System.out.println("2. Path normalization: Convert to real path and verify containment");
        System.out.println("3. Whitelist approach: Only allow access to predefined files");
        System.out.println("4. Canonical path verification: Ensure target is within base directory");
        System.out.println("5. File type validation: Verify target is a file, not directory");
    }
}
